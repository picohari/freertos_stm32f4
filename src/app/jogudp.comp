/*    This is a component of LinuxCNC for external step generator over Ethernet
 *    Copyright 2021 Juhász Zoltán <juhasz.zoltan at freemail dot hu>
 *
 *    version: 20250409
 *
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
 
 component jogudp "JOG2UDP";

 license "GPLv2 or later";
 author "[DK6YF) Harald Leschner";
 description "Sends axis positions and receives jog increments over UDP";
  
 pin in float disp.#.pos[3]     = 0.0  "Axis G54 (absolute) position";
 pin in float disp.#.vel[3]     = 0.0  "Axis current velocity";
 
 pin out s32 wheel.#.jog_delta[3]    = 0.0   "Jog count value for axis";
 pin out bit wheel.#.jog_enable[3]   = 0.0   "Enable jog on axis";
 pin out bit wheel.#.jog_scale[3]    = 0.0   "Scale jog on axis";
 
 pin out bit     in.#[7]     = 0     "Digital inputs";
 pin in  bit     out.#[6]    = 0     "Digital output";
 
 pin out bit     connected   = 0     "True if UDP socket is active";
 pin out s32     lost        = 0     "Lost packets";
 pin out bit     ready       = 0     "Module state";
 pin in  bit     enabled     = 0     "Module enable";
 
 
 /*---------------- ---------------------*/
 
 option singleton;
 option extra_setup;
 option extra_cleanup;
 
 function _;
 
 ;;
 
 /*-------------------------------------*/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdint.h>
 
 #include <string.h>
 #include <unistd.h>
 #include <arpa/inet.h>
 #include <sys/socket.h>
 #include <errno.h>
 
 
 
 #define BUFSIZE 64
 
 #define REMOTE_IP   "192.168.0.164"
 #define REMOTE_PORT 58427
 #define LOCAL_PORT  58428
 
 
 //#define CTRL_DIRSETUP 0b00000001
 //#define CTRL_ACCEL    0b00000010
 //#define CTRL_PWMFREQ  0b00000100
 #define CTRL_READY    0b01000000
 #define CTRL_ENABLE   0b10000000
 
 
 /* OUTPUTS: Data sent to remote controller */
 union {
     uint8_t rxbuf[BUFSIZE];
     
     /* IN: Received jogwheel state */
     struct {
         float    encoder_value; // 4
         int16_t  encoder_count; // 2
         uint16_t io;            // 2
         uint8_t  active_mask;   // 1 bitmask: bit0=X, bit1=Y, bit2=Z
         uint8_t  control;       // 1
         uint8_t  axis_select;   // 1
         uint8_t  range_mode;    // 1
     } jogstate;
     
 } Recv = { 0 };
 
 /* INPUTS: Data to send to remote control unit */
 union {
     uint8_t txbuf[BUFSIZE];
     
     /* OUT: Axis positions & speeds */
     struct {
         float    pos[3];         // 12 Actual machine position
         float    vel[3];         // 12 Calculated velocity
         float    scale[3];       // 12
         uint8_t  enable[3];      //  3
         uint8_t  control;        //  1 Control register feedback
         uint16_t io;             //  2 IO register multipurpose
     } fb;
     
 } Send = { 0 };
 
 int sockfd;
 struct sockaddr_in local_addr, remote_addr;
 socklen_t addr_len = sizeof(remote_addr);
 
 
 /*-------------------------------------*/
 
 EXTRA_SETUP()
 {
     // Create UDP socket
     if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
         perror("socket creation failed");
         exit(EXIT_FAILURE);
     }
     
     // Setup local address (for receiving)
     memset(&local_addr, 0, sizeof(local_addr));
     local_addr.sin_family = AF_INET;
     local_addr.sin_addr.s_addr = INADDR_ANY;
     local_addr.sin_port = htons(LOCAL_PORT);
     
     // Bind to local port
     if (bind(sockfd, (const struct sockaddr *)&local_addr, sizeof(local_addr)) < 0) {
         perror("bind failed");
         close(sockfd);
         exit(EXIT_FAILURE);
     }
     
     // Setup remote address (for sending)
     memset(&remote_addr, 0, sizeof(remote_addr));
     remote_addr.sin_family = AF_INET;
     //remote_addr.sin_addr.s_addr = inet_addr(REMOTE_IP);
     remote_addr.sin_port = htons(REMOTE_PORT);
     
     #if 0
     if (inet_pton(AF_INET, argv[1], &remote_addr.sin_addr) <= 0) {
         fprintf(stderr, "Invalid address: %s\n", argv[1]);
         close(sockfd);
         exit(EXIT_FAILURE);
     }
     #endif
     
     printf("UDP connection established\n");
     printf("Listening on port %d\n", LOCAL_PORT);
     printf("Sending to %s:%d\n", REMOTE_IP, REMOTE_PORT);
     
     // Example: Initialize some test data
     Send.fb.pos[0] = 100;
     Send.fb.pos[1] = 200;
     Send.fb.pos[2] = 300;
     Send.fb.vel[0] = 1.5f;
     Send.fb.vel[1] = 2.5f;
     Send.fb.vel[2] = 3.5f;
 
     return 0;
 }
 
 EXTRA_CLEANUP()
 {
     close(sockfd);
     return;
 }
 
 FUNCTION(_)
 {
     /* Send data to remote */
     if (enabled) {
         
         Send.fb.control = CTRL_ENABLE;
 
         for (int i = 0; i < 3; i++) {
             Send.fb.pos[i] = (float)disp_pos(i);
             Send.fb.vel[i] = (float)disp_pos(i);
         }
 
         for (int i = 0; i < 6; i++) {
             if (out(i)) Send.fb.io |= 1 << i;
         }
 
         ssize_t sent = sendto(sockfd, Send.txbuf, sizeof(Send.fb), 0,
                             (const struct sockaddr *)&remote_addr, sizeof(remote_addr));
 
         if (sent < 0) {
             perror("sendto failed");
         } else {
             printf("Sent %zd bytes\n", sent);
         }
     }
 
     
     /* Try to receive data (non-blocking with timeout) */
     fd_set readfds;
     struct timeval tv;
     FD_ZERO(&readfds);
     FD_SET(sockfd, &readfds);
     tv.tv_sec = 0;
     tv.tv_usec = 100000; // 100ms timeout
     
     int ret = select(sockfd + 1, &readfds, NULL, NULL, &tv);
     if (ret > 0) {
         ssize_t n = recvfrom(sockfd, Recv.rxbuf, BUFSIZE, 0,
                             (struct sockaddr *)&remote_addr, &addr_len);
         if (n > 0) {
 
             #if 1
             /* Receive axis values and parameters */
             for (int i = 0; i < 3; i++) {
                 wheel_jog_delta(i) = (uint32_t)Recv.jogstate.encoder_value;
                 //wheel_jog_enable(i) = Recv.param.enable[i];
                 //wheel_jog_scale(i)  = Recv.param.scale[i];
             }
             
             /* Receive IO */
             for (int i = 0; i < 7; i++)
                 in(i) = Recv.jogstate.io & (1 << i);
             
             /* Set ready pin */
             ready = Recv.jogstate.control & CTRL_READY;
             #endif
             
 
             #if 0
             printf("Received %zd bytes - encoder: %.2f, count: %d, mask: 0x%02x\n",
                    n, Recv.jogstate.encoder_value, 
                    Recv.jogstate.encoder_count,
                    Recv.jogstate.active_mask);
             #endif
 
         } else if (n < 0) {
             perror("recvfrom failed");
         }
     }
     
     //usleep(100000); // 100ms delay between cycles
 }
 